//Gyro
/*
 * ITG3200.c
 *
 *  Created on: Jun 6, 2016
 *      Author: Rafi
 */

#include "sensors.h"

int init_ITG3200(char addr)
{
	int itg_ready =0;
	unsigned char data[2];
	unsigned char* rdata;
	int itg_ready =0;

	// sample rate divider
	data[ADDRESS] = SAMPLE_RATE_DIV_REG;
	data[DATA] = SAMPLE_RATE_DIV_VALUE;
	if(I2C_IF_Write(addr, data, 2, true)<0)	return -1;
	while(I2CMasterBusy(I2CA0_BASE)){}

	// plpf and full scale
	data[ADDRESS] = DLPF_FULL_SCALE_REG;
	data[DATA] = DLPF_FULL_SCALE_VALUE;
	if(I2C_IF_Write(addr, data, 2, true)<0)	return -1;
	while(I2CMasterBusy(I2CA0_BASE)){}

	// interrupts configuration
	data[ADDRESS] = INTERRUPTS_CFG_REG;
	data[DATA] = INTERRUPTS_CFG_VALUE;
	if(I2C_IF_Write(addr, data, 2, true)<0)	return -1;
	while(I2CMasterBusy(I2CA0_BASE)){}

	// Power Management
	data[ADDRESS] = POWER_MNG_REG ;
	data[DATA] = POWER_MNG_VALUE;
	if(I2C_IF_Write(addr, data, 2, true)<0)	return -1;
	while(I2CMasterBusy(I2CA0_BASE)){}

	data[ADDRESS] = INTERRUPTS_STATUS_REG;
	while (!itg_ready){
		if(I2C_IF_Write(addr, data, 1, false)<0) {
			itg_ready =0;
			continue;
		}
		while(I2CMasterBusy(I2CA0_BASE)){}
		if(I2C_IF_Read(addr, rdata, 1)<0) {
			itg_ready =0;
			continue;
		}
		while(I2CMasterBusy(I2CA0_BASE)){}
		itg_ready =1;
	}

	return 0;
}



int ITG3200_read_accdata(char addr, Gyr_local_data* gyr_data)
{
	unsigned char data[2];
	unsigned char rdata[6];
	SHORT Xdata, Ydata, Zdata;

	data[ADDRESS] = GYRO_XOUT_HIGH_REG;
	if(I2C_IF_Write(addr, data, 1, false)<0)	return -1;
	while(I2CMasterBusy(I2CA0_BASE)){}
	if(I2C_IF_Read(addr, rdata, 6)<0)			return -2;
	while(I2CMasterBusy(I2CA0_BASE)){}

	gyr_data->Wx = (int)rdata[X_POS_H];
	gyr_data->Wx <<=I2C_REG_SIZE;
	gyr_data->Wx += (int)rdata[X_POS_L];

	gyr_data->Wy = (int)rdata[Y_POS_H];
	gyr_data->Wy <<=I2C_REG_SIZE;
	gyr_data->Wy += (int)rdata[Y_POS_L];

	gyr_data->Wz = (int)rdata[Z_POS_H];
	gyr_data->Wz <<=I2C_REG_SIZE;
	gyr_data->Wz += (int)rdata[Z_POS_L];

	*Xacc = ((float)Xdata) * 4 /1000;
	*Yacc = ((float)Ydata) * 4 /1000;
	*Zacc = ((float)Zdata) * 4 /1000;


	return 0;
}
